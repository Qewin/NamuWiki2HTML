#define CORE 4


*CacheList[10] //10 * 50 = 500(MB)
CSta
CEnd
isFinished[CORE-1]


main()
	open Namuwiki.json
	open Output.json
	
	CacheManage("INIT")
	cache = CacheManage("ReturnChunk")
	
	DocPointerList[10000]
	CDocPointerList[10000]
	
	//LOOP 
	While ( pointer = find(각 문서의 시작) ) is not NULL 
		DocPointerList[a] = pointer
		a++
	CutDOC = DocPointerList[a] //cutdoc은 잘려버린 불쌍한 문서. 
	DocPointerList[a~a+CORE-1] = NULL
	
	isFinished[0~CORE-2] = 1
	Parser(1~CORE-1,CORE-1,DocPointerList,CDocPointerList,Flag) // flag 는 isFinished의 포인터 
	while (isFinished[0~CORE-2] == 0 and CacheManage("ReturnChunk") != NULL and isFinished[0~CORE-2] != 0) ;
	while (isFinished[0~CORE-2] != 0)
		delay() //함수 찾아보기. 찾아보면 있다. 
	DocPointerList[START~] = DocPointerList[CutDOC~END]
	cache2 = CacheManage("ReturnChunk")
	if (cache2 == NULL)
		(끝내기 프로세스) 
		break 
	(이어붙이기)
	Parser(0,1,DocPointerList,CDocPointerList,Flag)
	cache = cache2
	(디스크에 쓰기)
	//LOOP
	
	



find("String")
	for Cache[a] Start to End
		if Cache[a] is "String" : Return a
		else if Cache[a] is EOF : Return NULL

Parser(Number,Multiplyer,DocPointerList,CDocPointerList,Flag)
	while(DocPointerList[Number+Multiplyer*a] is not NULL)
		(Parse)

CacheManage(mode)
	case mode = "INIT"
		CEnd = 1
		CSta = 0
		CacheList[CSta] = allocate Cache 50MB
		read Namuwiki.json -> Cache 50MB
		CacheList[CEnd] = allocate Cache 50MB
		read Namuwiki.json -> Cache 50MB
		return NULL 

	case mode = "Read"
		CEndC = CEnd
		if (CEnd > listSize) CEnd = 0 
		else CEnd++
		if (CEnd is CSta)
			CEnd = CEndC
			return NULL // if full

		CacheList[CEnd] = allocate Cache 50MB
		read Namuwiki.json -> Cache 50MB
		if ((Read Ends)) return NULL
		return CacheList[CEnd]

	case mode = "ReturnChunk"
		CST = CSta
		if (CSta > listSize) CSta = 0 
		else CSta++
		if (CSta is CEnd)
			CacheManage("Read")
		return CacheList[CST]
